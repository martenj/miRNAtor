// ______________________________________________________
// Generated by sql2java - http://sql2java.sourceforge.net/
// jdbc driver used at code generation time: org.postgresql.Driver
//
// Please help us improve this tool by reporting:
// - problems and suggestions to
//   http://sourceforge.net/tracker/?group_id=54687
// - feedbacks and ideas on
//   http://sourceforge.net/forum/forum.php?forum_id=182208
// ______________________________________________________

package mirnator.sql2java;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang.builder.CompareToBuilder;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.commons.lang.builder.ToStringStyle;

/**
 * FamilyBean is a mapping of family Table.
 * 
 * @author sql2java
 */
public class FamilyBean implements Serializable, GeneratedBean {
	private static final long serialVersionUID = -7831616246441342675L;

	private String familySequence;

	private boolean familySequenceIsModified = false;
	private boolean familySequenceIsInitialized = false;

	private String family;

	private boolean familyIsModified = false;
	private boolean familyIsInitialized = false;

	private String familyAccession;

	private boolean familyAccessionIsModified = false;
	private boolean familyAccessionIsInitialized = false;

	private Integer familyId;

	private boolean familyIdIsModified = false;
	private boolean familyIdIsInitialized = false;

	private boolean _isNew = true;

	/**
	 * Prefered methods to create a FamilyBean is via the createFamilyBean method in FamilyManager or via the factory
	 * class FamilyFactory create method
	 */
	protected FamilyBean() {
	}

	/**
	 * Getter method for familySequence. <br>
	 * Meta Data Information (in progress):
	 * <ul>
	 * <li>full name: family.family_sequence</li>
	 * <li>column size: 2147483647</li>
	 * <li>jdbc type returned by the driver: Types.VARCHAR</li>
	 * </ul>
	 *
	 * @return the value of familySequence
	 */
	public String getFamilySequence() {
		return familySequence;
	}

	/**
	 * Setter method for familySequence. <br>
	 * The new value is set only if compareTo() says it is different, or if one of either the new value or the current
	 * value is null. In case the new value is different, it is set and the field is marked as 'modified'.
	 *
	 * @param newVal
	 *            the new value to be assigned to familySequence
	 */
	public void setFamilySequence(String newVal) {
		if ((newVal != null && familySequence != null && (newVal.compareTo(familySequence) == 0))
				|| (newVal == null && familySequence == null && familySequenceIsInitialized)) {
			return;
		}
		familySequence = newVal;
		familySequenceIsModified = true;
		familySequenceIsInitialized = true;
	}

	/**
	 * Determines if the familySequence has been modified.
	 *
	 * @return true if the field has been modified, false if the field has not been modified
	 */
	public boolean isFamilySequenceModified() {
		return familySequenceIsModified;
	}

	/**
	 * Determines if the familySequence has been initialized. <br>
	 * It is useful to determine if a field is null on purpose or just because it has not been initialized.
	 *
	 * @return true if the field has been initialized, false otherwise
	 */
	public boolean isFamilySequenceInitialized() {
		return familySequenceIsInitialized;
	}

	/**
	 * Getter method for family. <br>
	 * Meta Data Information (in progress):
	 * <ul>
	 * <li>full name: family.family</li>
	 * <li>column size: 2147483647</li>
	 * <li>jdbc type returned by the driver: Types.VARCHAR</li>
	 * </ul>
	 *
	 * @return the value of family
	 */
	public String getFamily() {
		return family;
	}

	/**
	 * Setter method for family. <br>
	 * The new value is set only if compareTo() says it is different, or if one of either the new value or the current
	 * value is null. In case the new value is different, it is set and the field is marked as 'modified'.
	 *
	 * @param newVal
	 *            the new value to be assigned to family
	 */
	public void setFamily(String newVal) {
		if ((newVal != null && family != null && (newVal.compareTo(family) == 0))
				|| (newVal == null && family == null && familyIsInitialized)) {
			return;
		}
		family = newVal;
		familyIsModified = true;
		familyIsInitialized = true;
	}

	/**
	 * Determines if the family has been modified.
	 *
	 * @return true if the field has been modified, false if the field has not been modified
	 */
	public boolean isFamilyModified() {
		return familyIsModified;
	}

	/**
	 * Determines if the family has been initialized. <br>
	 * It is useful to determine if a field is null on purpose or just because it has not been initialized.
	 *
	 * @return true if the field has been initialized, false otherwise
	 */
	public boolean isFamilyInitialized() {
		return familyIsInitialized;
	}

	/**
	 * Getter method for familyAccession. <br>
	 * Meta Data Information (in progress):
	 * <ul>
	 * <li>full name: family.family_accession</li>
	 * <li>column size: 2147483647</li>
	 * <li>jdbc type returned by the driver: Types.VARCHAR</li>
	 * </ul>
	 *
	 * @return the value of familyAccession
	 */
	public String getFamilyAccession() {
		return familyAccession;
	}

	/**
	 * Setter method for familyAccession. <br>
	 * The new value is set only if compareTo() says it is different, or if one of either the new value or the current
	 * value is null. In case the new value is different, it is set and the field is marked as 'modified'.
	 *
	 * @param newVal
	 *            the new value to be assigned to familyAccession
	 */
	public void setFamilyAccession(String newVal) {
		if ((newVal != null && familyAccession != null && (newVal.compareTo(familyAccession) == 0))
				|| (newVal == null && familyAccession == null && familyAccessionIsInitialized)) {
			return;
		}
		familyAccession = newVal;
		familyAccessionIsModified = true;
		familyAccessionIsInitialized = true;
	}

	/**
	 * Determines if the familyAccession has been modified.
	 *
	 * @return true if the field has been modified, false if the field has not been modified
	 */
	public boolean isFamilyAccessionModified() {
		return familyAccessionIsModified;
	}

	/**
	 * Determines if the familyAccession has been initialized. <br>
	 * It is useful to determine if a field is null on purpose or just because it has not been initialized.
	 *
	 * @return true if the field has been initialized, false otherwise
	 */
	public boolean isFamilyAccessionInitialized() {
		return familyAccessionIsInitialized;
	}

	/**
	 * Getter method for familyId. <br>
	 * PRIMARY KEY.<br>
	 * Meta Data Information (in progress):
	 * <ul>
	 * <li>full name: family.family_id</li>
	 * <li>imported key: mirna.family_ref</li>
	 * <li>column size: 10</li>
	 * <li>jdbc type returned by the driver: Types.INTEGER</li>
	 * </ul>
	 *
	 * @return the value of familyId
	 */
	public Integer getFamilyId() {
		return familyId;
	}

	/**
	 * Setter method for familyId. <br>
	 * The new value is set only if compareTo() says it is different, or if one of either the new value or the current
	 * value is null. In case the new value is different, it is set and the field is marked as 'modified'.
	 *
	 * @param newVal
	 *            the new value to be assigned to familyId
	 */
	public void setFamilyId(Integer newVal) {
		if ((newVal != null && familyId != null && (newVal.compareTo(familyId) == 0))
				|| (newVal == null && familyId == null && familyIdIsInitialized)) {
			return;
		}
		familyId = newVal;
		familyIdIsModified = true;
		familyIdIsInitialized = true;
	}

	/**
	 * Setter method for familyId. <br>
	 * Convenient for those who do not want to deal with Objects for primary types.
	 *
	 * @param newVal
	 *            the new value to be assigned to familyId
	 */
	public void setFamilyId(int newVal) {
		setFamilyId(new Integer(newVal));
	}

	/**
	 * Determines if the familyId has been modified.
	 *
	 * @return true if the field has been modified, false if the field has not been modified
	 */
	public boolean isFamilyIdModified() {
		return familyIdIsModified;
	}

	/**
	 * Determines if the familyId has been initialized. <br>
	 * It is useful to determine if a field is null on purpose or just because it has not been initialized.
	 *
	 * @return true if the field has been initialized, false otherwise
	 */
	public boolean isFamilyIdInitialized() {
		return familyIdIsInitialized;
	}

	/**
	 * Determines if the current object is new.
	 *
	 * @return true if the current object is new, false if the object is not new
	 */
	public boolean isNew() {
		return _isNew;
	}

	/**
	 * Specifies to the object if it has been set as new.
	 *
	 * @param isNew
	 *            the boolean value to be assigned to the isNew field
	 */
	public void isNew(boolean isNew) {
		this._isNew = isNew;
	}

	/**
	 * Determines if the object has been modified since the last time this method was called. <br>
	 * We can also determine if this object has ever been modified since its creation.
	 *
	 * @return true if the object has been modified, false if the object has not been modified
	 */
	public boolean isModified() {
		return familySequenceIsModified || familyIsModified || familyAccessionIsModified || familyIdIsModified;
	}

	/**
	 * Resets the object modification status to 'not modified'.
	 */
	public void resetIsModified() {
		familySequenceIsModified = false;
		familyIsModified = false;
		familyAccessionIsModified = false;
		familyIdIsModified = false;
	}

	/**
	 * Copies the passed bean into the current bean.
	 *
	 * @param bean
	 *            the bean to copy into the current bean
	 */
	public void copy(FamilyBean bean) {
		setFamilySequence(bean.getFamilySequence());
		setFamily(bean.getFamily());
		setFamilyAccession(bean.getFamilyAccession());
		setFamilyId(bean.getFamilyId());
	}

	/**
	 * return a dictionnary of the object
	 */
	public Map<String, String> getDictionnary() {
		Map<String, String> dictionnary = new HashMap<String, String>();
		dictionnary.put("family_sequence", getFamilySequence() == null ? "" : getFamilySequence().toString());
		dictionnary.put("family", getFamily() == null ? "" : getFamily().toString());
		dictionnary.put("family_accession", getFamilyAccession() == null ? "" : getFamilyAccession().toString());
		dictionnary.put("family_id", getFamilyId() == null ? "" : getFamilyId().toString());
		return dictionnary;
	}

	/**
	 * return a dictionnary of the pk columns
	 */
	public Map<String, String> getPkDictionnary() {
		Map<String, String> dictionnary = new HashMap<String, String>();
		dictionnary.put("family_id", getFamilyId() == null ? "" : getFamilyId().toString());
		return dictionnary;
	}

	/**
	 * return a the value string representation of the given field
	 */
	public String getValue(String column) {
		if (null == column || "".equals(column)) {
			return "";
		} else if ("family_sequence".equalsIgnoreCase(column) || "familySequence".equalsIgnoreCase(column)) {
			return getFamilySequence() == null ? "" : getFamilySequence().toString();
		} else if ("family".equalsIgnoreCase(column) || "family".equalsIgnoreCase(column)) {
			return getFamily() == null ? "" : getFamily().toString();
		} else if ("family_accession".equalsIgnoreCase(column) || "familyAccession".equalsIgnoreCase(column)) {
			return getFamilyAccession() == null ? "" : getFamilyAccession().toString();
		} else if ("family_id".equalsIgnoreCase(column) || "familyId".equalsIgnoreCase(column)) {
			return getFamilyId() == null ? "" : getFamilyId().toString();
		}
		return "";
	}

	/**
	 * @see java.lang.Object#equals(Object)
	 */
	public boolean equals(Object object) {
		if (!(object instanceof FamilyBean)) {
			return false;
		}

		FamilyBean obj = (FamilyBean) object;
		return new EqualsBuilder().append(getFamilySequence(), obj.getFamilySequence())
				.append(getFamily(), obj.getFamily()).append(getFamilyAccession(), obj.getFamilyAccession())
				.append(getFamilyId(), obj.getFamilyId()).isEquals();
	}

	/**
	 * @see java.lang.Object#hashCode()
	 */
	public int hashCode() {
		return new HashCodeBuilder(-82280557, -700257973).append(getFamilySequence()).append(getFamily())
				.append(getFamilyAccession()).append(getFamilyId()).toHashCode();
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	public String toString() {
		return toString(ToStringStyle.MULTI_LINE_STYLE);
	}

	/**
	 * you can use the following styles: <li>ToStringStyle.DEFAULT_STYLE</li> <li>ToStringStyle.MULTI_LINE_STYLE</li>
	 * <li>ToStringStyle.NO_FIELD_NAMES_STYLE</li> <li>ToStringStyle.SHORT_PREFIX_STYLE</li> <li>
	 * ToStringStyle.SIMPLE_STYLE</li>
	 */
	public String toString(ToStringStyle style) {
		return new ToStringBuilder(this, style).append("family_sequence", getFamilySequence())
				.append("family", getFamily()).append("family_accession", getFamilyAccession())
				.append("family_id", getFamilyId()).toString();
	}

	public int compareTo(Object object) {
		FamilyBean obj = (FamilyBean) object;
		return new CompareToBuilder().append(getFamilySequence(), obj.getFamilySequence())
				.append(getFamily(), obj.getFamily()).append(getFamilyAccession(), obj.getFamilyAccession())
				.append(getFamilyId(), obj.getFamilyId()).toComparison();
	}
}
