// ______________________________________________________
// Generated by sql2java - http://sql2java.sourceforge.net/
// jdbc driver used at code generation time: org.postgresql.Driver
//
// Please help us improve this tool by reporting:
// - problems and suggestions to
//   http://sourceforge.net/tracker/?group_id=54687
// - feedbacks and ideas on
//   http://sourceforge.net/forum/forum.php?forum_id=182208
// ______________________________________________________

package mirnator.sql2java;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

import mirnator.sql2java.exception.DAOException;
import mirnator.sql2java.exception.DataAccessException;
import mirnator.sql2java.exception.ObjectRetrievalException;

/**
 * Handles database calls (save, load, count, etc...) for the expression_array table.
 * 
 * @author sql2java
 */
public class ExpressionArrayManager {

	/* set =QUERY for loadUsingTemplate */
	public static final int SEARCH_EXACT = 0;
	/* set %QUERY% for loadLikeTemplate */
	public static final int SEARCH_LIKE = 1;
	/* set %QUERY for loadLikeTemplate */
	public static final int SEARCH_STARTING_LIKE = 2;
	/* set QUERY% for loadLikeTemplate */
	public static final int SEARCH_ENDING_LIKE = 3;

	/**
	 * Identify the plattform field.
	 */
	public static final int ID_PLATTFORM = 0;

	/**
	 * Identify the title field.
	 */
	public static final int ID_TITLE = 1;

	/**
	 * Identify the gsm field.
	 */
	public static final int ID_GSM = 2;

	/**
	 * Identify the gse field.
	 */
	public static final int ID_GSE = 3;

	/**
	 * Identify the tissue field.
	 */
	public static final int ID_TISSUE = 4;

	/**
	 * Identify the array_id field.
	 */
	public static final int ID_ARRAY_ID = 5;

	/**
	 * Contains all the full fields of the expression_array table.
	 */
	private static final String[] FULL_FIELD_NAMES = { "expression_array.plattform", "expression_array.title",
			"expression_array.gsm", "expression_array.gse", "expression_array.tissue", "expression_array.array_id" };

	/**
	 * Contains all the fields of the expression_array table.
	 */
	public static final String[] FIELD_NAMES = { "plattform", "title", "gsm", "gse", "tissue", "array_id" };

	/**
	 * Field that contains the comma separated fields of the expression_array table.
	 */
	public static final String ALL_FULL_FIELDS = "expression_array.plattform" + ",expression_array.title"
			+ ",expression_array.gsm" + ",expression_array.gse" + ",expression_array.tissue"
			+ ",expression_array.array_id";

	/**
	 * Field that contains the comma separated fields of the expression_array table.
	 */
	public static final String ALL_FIELDS = "plattform" + ",title" + ",gsm" + ",gse" + ",tissue" + ",array_id";

	private static ExpressionArrayManager singleton = new ExpressionArrayManager();

	/**
	 * Get the ExpressionArrayManager singleton.
	 *
	 * @return ExpressionArrayManager
	 */
	public static ExpressionArrayManager getInstance() {
		return singleton;
	}

	/**
	 * Creates a new ExpressionArrayBean instance.
	 *
	 * @return the new ExpressionArrayBean
	 */
	public ExpressionArrayBean createExpressionArrayBean() {
		return new ExpressionArrayBean();
	}

	// ////////////////////////////////////
	// PRIMARY KEY METHODS
	// ////////////////////////////////////

	/**
	 * Loads a ExpressionArrayBean from the expression_array using its key fields.
	 *
	 * @param arrayId
	 *            String - PK# 1
	 * @return a unique ExpressionArrayBean
	 * @throws DAOException
	 */
	// 1
	public ExpressionArrayBean loadByPrimaryKey(String arrayId) throws DAOException {
		Connection c = null;
		PreparedStatement ps = null;
		try {
			c = this.getConnection();
			StringBuffer sql = new StringBuffer("SELECT " + ALL_FIELDS + " FROM expression_array WHERE array_id=?");
			// System.out.println("loadByPrimaryKey: " + sql);
			ps = c.prepareStatement(sql.toString(), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			if (arrayId == null) {
				ps.setNull(1, Types.VARCHAR);
			} else {
				ps.setString(1, arrayId);
			}
			ExpressionArrayBean pReturn[] = this.loadByPreparedStatement(ps);
			if (pReturn.length < 1) {
				throw new ObjectRetrievalException();
			} else {
				return pReturn[0];
			}
		} catch (SQLException e) {
			throw new ObjectRetrievalException(e);
		} finally {
			this.getManager().close(ps);
			this.freeConnection(c);
		}
	}

	/**
	 * Deletes rows according to its keys.
	 *
	 * @param arrayId
	 *            String - PK# 1
	 * @return the number of deleted rows
	 * @throws DAOException
	 */
	// 2
	public int deleteByPrimaryKey(String arrayId) throws DAOException {
		Connection c = null;
		PreparedStatement ps = null;
		try {
			c = this.getConnection();
			StringBuffer sql = new StringBuffer("DELETE FROM expression_array WHERE array_id=?");
			// System.out.println("deleteByPrimaryKey: " + sql);
			ps = c.prepareStatement(sql.toString(), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			if (arrayId == null) {
				ps.setNull(1, Types.VARCHAR);
			} else {
				ps.setString(1, arrayId);
			}
			return ps.executeUpdate();
		} catch (SQLException e) {
			throw new DataAccessException(e);
		} finally {
			this.getManager().close(ps);
			this.freeConnection(c);
		}
	}

	// ////////////////////////////////////
	// LOAD ALL
	// ////////////////////////////////////

	/**
	 * Loads all the rows from expression_array.
	 *
	 * @return an array of ExpressionArrayManager bean
	 * @throws DAOException
	 */
	// 5
	public ExpressionArrayBean[] loadAll() throws DAOException {
		return this.loadUsingTemplate(null);
	}

	/**
	 * Loads the given number of rows from expression_array, given the start row.
	 *
	 * @param startRow
	 *            the start row to be used (first row = 1, last row = -1)
	 * @param numRows
	 *            the number of rows to be retrieved (all rows = a negative number)
	 * @return an array of ExpressionArrayManager bean
	 * @throws DAOException
	 */
	// 6
	public ExpressionArrayBean[] loadAll(int startRow, int numRows) throws DAOException {
		return this.loadUsingTemplate(null, startRow, numRows);
	}

	// ////////////////////////////////////
	// SQL 'WHERE' METHOD
	// ////////////////////////////////////
	/**
	 * Retrieves an array of ExpressionArrayBean given a sql 'where' clause.
	 *
	 * @param where
	 *            the sql 'where' clause
	 * @return the resulting ExpressionArrayBean table
	 * @throws DAOException
	 */
	// 7
	public ExpressionArrayBean[] loadByWhere(String where) throws DAOException {
		return this.loadByWhere(where, null);
	}

	/**
	 * Retrieves an array of ExpressionArrayBean given a sql where clause, and a list of fields. It is up to you to pass
	 * the 'WHERE' in your where clausis.
	 *
	 * @param where
	 *            the sql 'WHERE' clause
	 * @param fieldList
	 *            array of field's ID
	 * @return the resulting ExpressionArrayBean table
	 * @throws DAOException
	 */
	// 8
	public ExpressionArrayBean[] loadByWhere(String where, int[] fieldList) throws DAOException {
		return this.loadByWhere(where, fieldList, 1, -1);
	}

	/**
	 * Retrieves an array of ExpressionArrayBean given a sql where clause and a list of fields, and startRow and
	 * numRows. It is up to you to pass the 'WHERE' in your where clausis.
	 *
	 * @param where
	 *            the sql 'where' clause
	 * @param startRow
	 *            the start row to be used (first row = 1, last row = -1)
	 * @param numRows
	 *            the number of rows to be retrieved (all rows = a negative number)
	 * @param fieldList
	 *            table of the field's associated constants
	 * @return the resulting ExpressionArrayBean table
	 * @throws DAOException
	 */
	// 9
	public ExpressionArrayBean[] loadByWhere(String where, int[] fieldList, int startRow, int numRows)
			throws DAOException {
		StringBuffer sql = new StringBuffer(128);
		if (fieldList == null) {
			sql.append("SELECT ").append(ALL_FIELDS).append(" FROM expression_array ").append(where);
		} else {
			sql.append("SELECT ");
			for (int i = 0; i < fieldList.length; i++) {
				if (i != 0) {
					sql.append(",");
				}
				sql.append(FULL_FIELD_NAMES[fieldList[i]]);
			}
			sql.append(" FROM expression_array ");
			sql.append(where);
		}
		Connection c = null;
		Statement st = null;
		ResultSet rs = null;
		// System.out.println("loadByWhere: " + sql);
		try {
			c = this.getConnection();
			st = c.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			rs = st.executeQuery(sql.toString());
			return this.decodeResultSet(rs, fieldList, startRow, numRows);
		} catch (SQLException e) {
			throw new ObjectRetrievalException(e);
		} finally {
			sql = null;
			this.getManager().close(st, rs);
			this.freeConnection(c);
		}
	}

	/**
	 * Deletes all rows from expression_array table.
	 * 
	 * @return the number of deleted rows.
	 * @throws DAOException
	 */
	// 10
	public int deleteAll() throws DAOException {
		return this.deleteByWhere("");
	}

	/**
	 * Deletes rows from the expression_array table using a 'where' clause. It is up to you to pass the 'WHERE' in your
	 * where clausis. <br>
	 * Attention, if 'WHERE' is omitted it will delete all records.
	 *
	 * @param where
	 *            the sql 'where' clause
	 * @return the number of deleted rows
	 * @throws DAOException
	 */
	// 11
	public int deleteByWhere(String where) throws DAOException {
		Connection c = null;
		PreparedStatement ps = null;

		try {
			c = this.getConnection();
			StringBuffer sql = new StringBuffer("DELETE FROM expression_array " + where);
			// System.out.println("deleteByWhere: " + sql);
			ps = c.prepareStatement(sql.toString());
			return ps.executeUpdate();
		} catch (SQLException e) {
			throw new DataAccessException(e);
		} finally {
			this.getManager().close(ps);
			this.freeConnection(c);
		}
	}

	// _____________________________________________________________________
	//
	// SAVE
	// _____________________________________________________________________
	/**
	 * Saves the ExpressionArrayBean bean into the database.
	 *
	 * @param bean
	 *            the ExpressionArrayBean bean to be saved
	 * @return the inserted or updated bean
	 * @throws DAOException
	 */
	// 12
	public ExpressionArrayBean save(ExpressionArrayBean bean) throws DAOException {
		if (bean.isNew()) {
			return this.insert(bean);
		} else {
			return this.update(bean);
		}
	}

	/**
	 * Insert the ExpressionArrayBean bean into the database.
	 *
	 * @param bean
	 *            the ExpressionArrayBean bean to be saved
	 * @return the inserted bean
	 * @throws DAOException
	 */
	// 13
	public ExpressionArrayBean insert(ExpressionArrayBean bean) throws DAOException {
		// mini checks
		if (!bean.isModified()) {
			return bean; // should not we log something ?
		}
		if (!bean.isNew()) {
			return this.update(bean);
		}

		Connection c = null;
		PreparedStatement ps = null;
		StringBuffer sql = null;

		try {
			c = this.getConnection();
			this.beforeInsert(bean); // listener callback
			int _dirtyCount = 0;
			sql = new StringBuffer("INSERT into expression_array (");

			if (bean.isPlattformModified()) {
				if (_dirtyCount > 0) {
					sql.append(",");
				}
				sql.append("plattform");
				_dirtyCount++;
			}

			if (bean.isTitleModified()) {
				if (_dirtyCount > 0) {
					sql.append(",");
				}
				sql.append("title");
				_dirtyCount++;
			}

			if (bean.isGsmModified()) {
				if (_dirtyCount > 0) {
					sql.append(",");
				}
				sql.append("gsm");
				_dirtyCount++;
			}

			if (bean.isGseModified()) {
				if (_dirtyCount > 0) {
					sql.append(",");
				}
				sql.append("gse");
				_dirtyCount++;
			}

			if (bean.isTissueModified()) {
				if (_dirtyCount > 0) {
					sql.append(",");
				}
				sql.append("tissue");
				_dirtyCount++;
			}

			if (bean.isArrayIdModified()) {
				if (_dirtyCount > 0) {
					sql.append(",");
				}
				sql.append("array_id");
				_dirtyCount++;
			}

			sql.append(") values (");
			if (_dirtyCount > 0) {
				sql.append("?");
				for (int i = 1; i < _dirtyCount; i++) {
					sql.append(",?");
				}
			}
			sql.append(")");

			// System.out.println("insert : " + sql.toString());

			ps = c.prepareStatement(sql.toString(), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);

			this.fillPreparedStatement(ps, bean, SEARCH_EXACT);

			ps.executeUpdate();

			bean.isNew(false);
			bean.resetIsModified();
			this.afterInsert(bean); // listener callback
			return bean;
		} catch (SQLException e) {
			throw new DataAccessException(e);
		} finally {
			sql = null;
			this.getManager().close(ps);
			this.freeConnection(c);
		}
	}

	/**
	 * Update the ExpressionArrayBean bean record in the database according to the changes.
	 *
	 * @param bean
	 *            the ExpressionArrayBean bean to be updated
	 * @return the updated bean
	 * @throws DAOException
	 */
	// 14
	public ExpressionArrayBean update(ExpressionArrayBean bean) throws DAOException {
		// mini checks
		if (!bean.isModified()) {
			return bean; // should not we log something ?
		}
		if (bean.isNew()) {
			return this.insert(bean);
		}

		Connection c = null;
		PreparedStatement ps = null;
		StringBuffer sql = null;

		try {
			c = this.getConnection();

			this.beforeUpdate(bean); // listener callback
			sql = new StringBuffer("UPDATE expression_array SET ");
			boolean useComma = false;

			if (bean.isPlattformModified()) {
				if (useComma) {
					sql.append(", ");
				} else {
					useComma = true;
				}
				sql.append("plattform=?");
			}

			if (bean.isTitleModified()) {
				if (useComma) {
					sql.append(", ");
				} else {
					useComma = true;
				}
				sql.append("title=?");
			}

			if (bean.isGsmModified()) {
				if (useComma) {
					sql.append(", ");
				} else {
					useComma = true;
				}
				sql.append("gsm=?");
			}

			if (bean.isGseModified()) {
				if (useComma) {
					sql.append(", ");
				} else {
					useComma = true;
				}
				sql.append("gse=?");
			}

			if (bean.isTissueModified()) {
				if (useComma) {
					sql.append(", ");
				} else {
					useComma = true;
				}
				sql.append("tissue=?");
			}

			if (bean.isArrayIdModified()) {
				if (useComma) {
					sql.append(", ");
				} else {
					useComma = true;
				}
				sql.append("array_id=?");
			}
			sql.append(" WHERE ");
			sql.append("array_id=?");
			// System.out.println("update : " + sql.toString());
			ps = c.prepareStatement(sql.toString(), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);

			int _dirtyCount = this.fillPreparedStatement(ps, bean, SEARCH_EXACT);

			if (_dirtyCount == 0) {
				// System.out.println("The bean to look is not initialized... do not update.");
				return bean;
			}

			if (bean.getArrayId() == null) {
				ps.setNull(++_dirtyCount, Types.VARCHAR);
			} else {
				ps.setString(++_dirtyCount, bean.getArrayId());
			}
			ps.executeUpdate();
			bean.resetIsModified();
			this.afterUpdate(bean); // listener callback

			return bean;
		} catch (SQLException e) {
			throw new DataAccessException(e);
		} finally {
			sql = null;
			this.getManager().close(ps);
			this.freeConnection(c);
		}
	}

	/**
	 * Saves an array of ExpressionArrayBean beans into the database.
	 *
	 * @param beans
	 *            the ExpressionArrayBean bean table to be saved
	 * @return the saved ExpressionArrayBean array.
	 * @throws DAOException
	 */
	// 15
	public ExpressionArrayBean[] save(ExpressionArrayBean[] beans) throws DAOException {
		for (int iIndex = 0; iIndex < beans.length; iIndex++) {
			this.save(beans[iIndex]);
		}
		return beans;
	}

	/**
	 * Insert an array of ExpressionArrayBean beans into the database.
	 *
	 * @param beans
	 *            the ExpressionArrayBean bean table to be inserted
	 * @return the saved ExpressionArrayBean array.
	 * @throws DAOException
	 */
	// 16
	public ExpressionArrayBean[] insert(ExpressionArrayBean[] beans) throws DAOException {
		return this.save(beans);
	}

	/**
	 * Updates an array of ExpressionArrayBean beans into the database.
	 *
	 * @param beans
	 *            the ExpressionArrayBean bean table to be inserted
	 * @return the saved ExpressionArrayBean array.
	 * @throws DAOException
	 */
	// 17
	public ExpressionArrayBean[] update(ExpressionArrayBean[] beans) throws DAOException {
		return this.save(beans);
	}

	// _____________________________________________________________________
	//
	// USING TEMPLATE
	// _____________________________________________________________________
	/**
	 * Loads a unique ExpressionArrayBean bean from a template one giving a c
	 *
	 * @param bean
	 *            the ExpressionArrayBean bean to look for
	 * @return the bean matching the template
	 * @throws DAOException
	 */
	// 18
	public ExpressionArrayBean loadUniqueUsingTemplate(ExpressionArrayBean bean) throws DAOException {
		ExpressionArrayBean[] beans = this.loadUsingTemplate(bean);
		if (beans.length == 0) {
			return null;
		}
		if (beans.length > 1) {
			throw new ObjectRetrievalException("More than one element !!");
		}
		return beans[0];
	}

	/**
	 * Loads an array of ExpressionArrayBean from a template one.
	 *
	 * @param bean
	 *            the ExpressionArrayBean template to look for
	 * @return all the ExpressionArrayBean matching the template
	 * @throws DAOException
	 */
	// 19
	public ExpressionArrayBean[] loadUsingTemplate(ExpressionArrayBean bean) throws DAOException {
		return this.loadUsingTemplate(bean, 1, -1);
	}

	/**
	 * Loads an array of ExpressionArrayBean from a template one, given the start row and number of rows.
	 *
	 * @param bean
	 *            the ExpressionArrayBean template to look for
	 * @param startRow
	 *            the start row to be used (first row = 1, last row=-1)
	 * @param numRows
	 *            the number of rows to be retrieved (all rows = a negative number)
	 * @return all the ExpressionArrayBean matching the template
	 * @throws DAOException
	 */
	// 20
	public ExpressionArrayBean[] loadUsingTemplate(ExpressionArrayBean bean, int startRow, int numRows)
			throws DAOException {
		return this.loadUsingTemplate(bean, startRow, numRows, SEARCH_EXACT);
	}

	/**
	 * Loads an array of ExpressionArrayBean from a template one, given the start row and number of rows.
	 *
	 * @param bean
	 *            the ExpressionArrayBean template to look for
	 * @param startRow
	 *            the start row to be used (first row = 1, last row=-1)
	 * @param numRows
	 *            the number of rows to be retrieved (all rows = a negative number)
	 * @param searchType
	 *            exact ? like ? starting like ?
	 * @return all the ExpressionArrayBean matching the template
	 * @throws DAOException
	 */
	// 20
	public ExpressionArrayBean[] loadUsingTemplate(ExpressionArrayBean bean, int startRow, int numRows, int searchType)
			throws DAOException {
		// System.out.println("loadUsingTemplate startRow:" + startRow + ", numRows:" + numRows + ", searchType:" +
		// searchType);
		Connection c = null;
		PreparedStatement ps = null;
		StringBuffer sql = new StringBuffer(128);
		sql.append("SELECT ").append(ALL_FIELDS).append(" FROM expression_array ");
		StringBuffer sqlWhere = new StringBuffer("");

		try {
			if (this.fillWhere(sqlWhere, bean, searchType) > 0) {
				sql.append(" WHERE ").append(sqlWhere);
			} else {
				// System.out.println("The bean to look is not initialized... loading all");
			}
			// System.out.println("loadUsingTemplate: " + sql.toString());

			c = this.getConnection();
			int scrollType = ResultSet.TYPE_SCROLL_INSENSITIVE;
			if (startRow != 1) {
				scrollType = ResultSet.TYPE_SCROLL_SENSITIVE;
			}
			ps = c.prepareStatement(sql.toString(), scrollType, ResultSet.CONCUR_READ_ONLY);
			this.fillPreparedStatement(ps, bean, searchType);

			ps.executeQuery();
			return this.loadByPreparedStatement(ps, null, startRow, numRows);
		} catch (SQLException e) {
			throw new ObjectRetrievalException(e);
		} finally {
			this.getManager().close(ps);
			this.freeConnection(c);
			sql = null;
			sqlWhere = null;
		}
	}

	/**
	 * Deletes rows using a ExpressionArrayBean template.
	 *
	 * @param bean
	 *            the ExpressionArrayBean object(s) to be deleted
	 * @return the number of deleted objects
	 * @throws DAOException
	 */
	// 21
	public int deleteUsingTemplate(ExpressionArrayBean bean) throws DAOException {
		if (bean.isArrayIdInitialized()) {
			return this.deleteByPrimaryKey(bean.getArrayId());
		}
		Connection c = null;
		PreparedStatement ps = null;
		StringBuffer sql = new StringBuffer("DELETE FROM expression_array ");
		StringBuffer sqlWhere = new StringBuffer("");

		try {
			this.beforeDelete(bean); // listener callback
			if (this.fillWhere(sqlWhere, bean, SEARCH_EXACT) > 0) {
				sql.append(" WHERE ").append(sqlWhere);
			} else {
				// System.out.println("The bean to look is not initialized... deleting all");
			}
			// System.out.println("deleteUsingTemplate: " + sql.toString());

			c = this.getConnection();
			ps = c.prepareStatement(sql.toString(), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			this.fillPreparedStatement(ps, bean, SEARCH_EXACT);

			int _rows = ps.executeUpdate();
			this.afterDelete(bean); // listener callback
			return _rows;
		} catch (SQLException e) {
			throw new DataAccessException(e);
		} finally {
			this.getManager().close(ps);
			this.freeConnection(c);
			sql = null;
			sqlWhere = null;
		}
	}

	// _____________________________________________________________________
	//
	// COUNT
	// _____________________________________________________________________

	/**
	 * Retrieves the number of rows of the table expression_array.
	 *
	 * @return the number of rows returned
	 * @throws DAOException
	 */
	// 24
	public int countAll() throws DAOException {
		return this.countWhere("");
	}

	/**
	 * Retrieves the number of rows of the table expression_array with a 'where' clause. It is up to you to pass the
	 * 'WHERE' in your where clausis.
	 *
	 * @param where
	 *            the restriction clause
	 * @return the number of rows returned
	 * @throws DAOException
	 */
	// 25
	public int countWhere(String where) throws DAOException {
		String sql = "SELECT COUNT(*) AS MCOUNT FROM expression_array " + where;
		// System.out.println("countWhere: " + sql);
		Connection c = null;
		Statement st = null;
		ResultSet rs = null;
		try {
			int iReturn = -1;
			c = this.getConnection();
			st = c.createStatement();
			rs = st.executeQuery(sql);
			if (rs.next()) {
				iReturn = rs.getInt("MCOUNT");
			}
			if (iReturn != -1) {
				return iReturn;
			}
		} catch (SQLException e) {
			throw new DataAccessException(e);
		} finally {
			this.getManager().close(st, rs);
			this.freeConnection(c);
			sql = null;
		}
		throw new DataAccessException("Error in countWhere where=[" + where + "]");
	}

	/**
	 * Retrieves the number of rows of the table expression_array with a prepared statement.
	 *
	 * @param ps
	 *            the PreparedStatement to be used
	 * @return the number of rows returned
	 * @throws DAOException
	 */
	// 26
	private int countByPreparedStatement(PreparedStatement ps) throws DAOException {
		ResultSet rs = null;
		try {
			int iReturn = -1;
			rs = ps.executeQuery();
			if (rs.next()) {
				iReturn = rs.getInt("MCOUNT");
			}
			if (iReturn != -1) {
				return iReturn;
			}
		} catch (SQLException e) {
			throw new DataAccessException(e);
		} finally {
			this.getManager().close(rs);
		}
		throw new DataAccessException("Error in countByPreparedStatement");
	}

	/**
	 * count the number of elements of a specific ExpressionArrayBean bean
	 *
	 * @param bean
	 *            the ExpressionArrayBean bean to look for ant count
	 * @return the number of rows returned
	 * @throws DAOException
	 */
	// 27
	public int countUsingTemplate(ExpressionArrayBean bean) throws DAOException {
		return this.countUsingTemplate(bean, -1, -1);
	}

	/**
	 * count the number of elements of a specific ExpressionArrayBean bean , given the start row and number of rows.
	 *
	 * @param bean
	 *            the ExpressionArrayBean template to look for and count
	 * @param startRow
	 *            the start row to be used (first row = 1, last row=-1)
	 * @param numRows
	 *            the number of rows to be retrieved (all rows = a negative number)
	 * @return the number of rows returned
	 * @throws DAOException
	 */
	// 20
	public int countUsingTemplate(ExpressionArrayBean bean, int startRow, int numRows) throws DAOException {
		return this.countUsingTemplate(bean, startRow, numRows, SEARCH_EXACT);
	}

	/**
	 * count the number of elements of a specific ExpressionArrayBean bean given the start row and number of rows and
	 * the search type
	 *
	 * @param bean
	 *            the ExpressionArrayBean template to look for
	 * @param startRow
	 *            the start row to be used (first row = 1, last row=-1)
	 * @param numRows
	 *            the number of rows to be retrieved (all rows = a negative number)
	 * @param searchType
	 *            exact ? like ? starting like ?
	 * @return the number of rows returned
	 * @throws DAOException
	 */
	// 20
	public int countUsingTemplate(ExpressionArrayBean bean, int startRow, int numRows, int searchType)
			throws DAOException {
		Connection c = null;
		PreparedStatement ps = null;
		StringBuffer sql = new StringBuffer("SELECT COUNT(*) AS MCOUNT FROM expression_array");
		StringBuffer sqlWhere = new StringBuffer("");

		try {
			if (this.fillWhere(sqlWhere, bean, SEARCH_EXACT) > 0) {
				sql.append(" WHERE ").append(sqlWhere);
			} else {
				// System.out.println("The bean to look is not initialized... counting all...");
			}
			// System.out.println("countUsingTemplate: " + sql.toString());

			c = this.getConnection();
			ps = c.prepareStatement(sql.toString(), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			this.fillPreparedStatement(ps, bean, searchType);

			return this.countByPreparedStatement(ps);
		} catch (SQLException e) {
			throw new DataAccessException(e);
		} finally {
			this.getManager().close(ps);
			this.freeConnection(c);
			sql = null;
			sqlWhere = null;
		}
	}

	//

	/**
	 * fills the given stringbuffer with the sql where clausis constructed using the bean and the search type
	 * 
	 * @param sqlWhere
	 *            the stringbuffer that will be filled
	 * @param bean
	 *            the bean to use for creating the where clausis
	 * @param searchType
	 *            exact ? like ? starting like ?
	 * @return the number of clausis returned
	 */
	protected int fillWhere(StringBuffer sqlWhere, ExpressionArrayBean bean, int searchType) {
		if (bean == null) {
			return 0;
		}
		int _dirtyCount = 0;
		String sqlEqualsOperation = "=";
		if (searchType != SEARCH_EXACT) {
			sqlEqualsOperation = " like ";
		}
		try {
			if (bean.isPlattformModified()) {
				_dirtyCount++;
				if (bean.getPlattform() == null) {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("plattform IS NULL");
				} else {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("plattform ")
							.append(sqlEqualsOperation).append("?");
				}
			}
			if (bean.isTitleModified()) {
				_dirtyCount++;
				if (bean.getTitle() == null) {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("title IS NULL");
				} else {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("title ")
							.append(sqlEqualsOperation).append("?");
				}
			}
			if (bean.isGsmModified()) {
				_dirtyCount++;
				if (bean.getGsm() == null) {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("gsm IS NULL");
				} else {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("gsm ").append(sqlEqualsOperation)
							.append("?");
				}
			}
			if (bean.isGseModified()) {
				_dirtyCount++;
				if (bean.getGse() == null) {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("gse IS NULL");
				} else {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("gse ").append(sqlEqualsOperation)
							.append("?");
				}
			}
			if (bean.isTissueModified()) {
				_dirtyCount++;
				if (bean.getTissue() == null) {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("tissue IS NULL");
				} else {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("tissue ")
							.append(sqlEqualsOperation).append("?");
				}
			}
			if (bean.isArrayIdModified()) {
				_dirtyCount++;
				if (bean.getArrayId() == null) {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("array_id IS NULL");
				} else {
					sqlWhere.append((sqlWhere.length() == 0) ? " " : " AND ").append("array_id ")
							.append(sqlEqualsOperation).append("?");
				}
			}
		} finally {
			sqlEqualsOperation = null;
		}
		return _dirtyCount;
	}

	/**
	 * fill the given prepared statement with the bean values and a search type
	 * 
	 * @param ps
	 *            the preparedStatement that will be filled
	 * @param bean
	 *            the bean to use for creating the where clausis
	 * @param searchType
	 *            exact ? like ? starting like ?
	 * @return the number of clausis returned
	 * @throws DAOException
	 */
	protected int fillPreparedStatement(PreparedStatement ps, ExpressionArrayBean bean, int searchType)
			throws DAOException {
		if (bean == null) {
			return 0;
		}
		int _dirtyCount = 0;
		try {
			if (bean.isPlattformModified()) {
				switch (searchType) {
				case SEARCH_EXACT:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getPlattform() + "]");
					if (bean.getPlattform() == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getPlattform());
					}
					break;
				case SEARCH_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getPlattform() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getPlattform() + "%");
					break;
				case SEARCH_STARTING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getPlattform() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getPlattform());
					break;
				case SEARCH_ENDING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getPlattform() + "]");
					if (bean.getPlattform() + "%" == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getPlattform() + "%");
					}
					break;
				default:
					throw new DAOException("Unknown search type " + searchType);
				}
			}
			if (bean.isTitleModified()) {
				switch (searchType) {
				case SEARCH_EXACT:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getTitle() + "]");
					if (bean.getTitle() == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getTitle());
					}
					break;
				case SEARCH_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getTitle() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getTitle() + "%");
					break;
				case SEARCH_STARTING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getTitle() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getTitle());
					break;
				case SEARCH_ENDING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getTitle() + "]");
					if (bean.getTitle() + "%" == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getTitle() + "%");
					}
					break;
				default:
					throw new DAOException("Unknown search type " + searchType);
				}
			}
			if (bean.isGsmModified()) {
				switch (searchType) {
				case SEARCH_EXACT:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getGsm() + "]");
					if (bean.getGsm() == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getGsm());
					}
					break;
				case SEARCH_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getGsm() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getGsm() + "%");
					break;
				case SEARCH_STARTING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getGsm() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getGsm());
					break;
				case SEARCH_ENDING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getGsm() + "]");
					if (bean.getGsm() + "%" == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getGsm() + "%");
					}
					break;
				default:
					throw new DAOException("Unknown search type " + searchType);
				}
			}
			if (bean.isGseModified()) {
				switch (searchType) {
				case SEARCH_EXACT:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getGse() + "]");
					if (bean.getGse() == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getGse());
					}
					break;
				case SEARCH_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getGse() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getGse() + "%");
					break;
				case SEARCH_STARTING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getGse() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getGse());
					break;
				case SEARCH_ENDING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getGse() + "]");
					if (bean.getGse() + "%" == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getGse() + "%");
					}
					break;
				default:
					throw new DAOException("Unknown search type " + searchType);
				}
			}
			if (bean.isTissueModified()) {
				switch (searchType) {
				case SEARCH_EXACT:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getTissue() + "]");
					if (bean.getTissue() == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getTissue());
					}
					break;
				case SEARCH_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getTissue() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getTissue() + "%");
					break;
				case SEARCH_STARTING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getTissue() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getTissue());
					break;
				case SEARCH_ENDING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getTissue() + "]");
					if (bean.getTissue() + "%" == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getTissue() + "%");
					}
					break;
				default:
					throw new DAOException("Unknown search type " + searchType);
				}
			}
			if (bean.isArrayIdModified()) {
				switch (searchType) {
				case SEARCH_EXACT:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getArrayId() + "]");
					if (bean.getArrayId() == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getArrayId());
					}
					break;
				case SEARCH_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getArrayId() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getArrayId() + "%");
					break;
				case SEARCH_STARTING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [" + bean.getArrayId() + "%]");
					ps.setString(++_dirtyCount, "%" + bean.getArrayId());
					break;
				case SEARCH_ENDING_LIKE:
					// System.out.println("Setting for " + _dirtyCount + " [%" + bean.getArrayId() + "]");
					if (bean.getArrayId() + "%" == null) {
						ps.setNull(++_dirtyCount, Types.VARCHAR);
					} else {
						ps.setString(++_dirtyCount, bean.getArrayId() + "%");
					}
					break;
				default:
					throw new DAOException("Unknown search type " + searchType);
				}
			}
		} catch (SQLException e) {
			throw new DataAccessException(e);
		}
		return _dirtyCount;
	}

	// _____________________________________________________________________
	//
	// DECODE RESULT SET
	// _____________________________________________________________________

	/**
	 * decode a resultset in an array of ExpressionArrayBean objects
	 *
	 * @param rs
	 *            the resultset to decode
	 * @param fieldList
	 *            table of the field's associated constants
	 * @param startRow
	 *            the start row to be used (first row = 1, last row = -1)
	 * @param numRows
	 *            the number of rows to be retrieved (all rows = a negative number)
	 * @return the resulting ExpressionArrayBean table
	 * @throws DAOException
	 */
	// 28
	public ExpressionArrayBean[] decodeResultSet(ResultSet rs, int[] fieldList, int startRow, int numRows)
			throws DAOException {
		List<ExpressionArrayBean> v = new ArrayList<ExpressionArrayBean>();
		try {
			if (rs.absolute(startRow) && numRows != 0) {
				int count = 0;
				if (fieldList == null) {
					do {
						v.add(decodeRow(rs));
						count++;
					} while ((count < numRows || numRows < 0) && rs.next());
				} else {
					do {
						v.add(decodeRow(rs, fieldList));
						count++;
					} while ((count < numRows || numRows < 0) && rs.next());
				}
			}
			return (ExpressionArrayBean[]) v.toArray(new ExpressionArrayBean[v.size()]);
		} catch (SQLException e) {
			throw new DataAccessException(e);
		} finally {
			if (v != null) {
				v.clear();
				v = null;
			}
		}
	}

	/**
	 * Transforms a ResultSet iterating on the expression_array on a ExpressionArrayBean bean.
	 *
	 * @param rs
	 *            the ResultSet to be transformed
	 * @return bean resulting ExpressionArrayBean bean
	 * @throws DAOException
	 */
	// 29
	public ExpressionArrayBean decodeRow(ResultSet rs) throws DAOException {
		ExpressionArrayBean bean = this.createExpressionArrayBean();
		try {
			bean.setPlattform(rs.getString(1));
			bean.setTitle(rs.getString(2));
			bean.setGsm(rs.getString(3));
			bean.setGse(rs.getString(4));
			bean.setTissue(rs.getString(5));
			bean.setArrayId(rs.getString(6));
		} catch (SQLException e) {
			throw new DataAccessException(e);
		}
		bean.isNew(false);
		bean.resetIsModified();

		return bean;
	}

	/**
	 * Transforms a ResultSet iterating on the expression_array table on a ExpressionArrayBean bean according to a list
	 * of fields.
	 *
	 * @param rs
	 *            the ResultSet to be transformed
	 * @param fieldList
	 *            table of the field's associated constants
	 * @return bean resulting ExpressionArrayBean bean
	 * @throws DAOException
	 */
	// 30
	public ExpressionArrayBean decodeRow(ResultSet rs, int[] fieldList) throws DAOException {
		ExpressionArrayBean bean = this.createExpressionArrayBean();
		int pos = 0;
		try {
			for (int i = 0; i < fieldList.length; i++) {
				switch (fieldList[i]) {
				case ID_PLATTFORM:
					++pos;
					bean.setPlattform(rs.getString(pos));
					break;
				case ID_TITLE:
					++pos;
					bean.setTitle(rs.getString(pos));
					break;
				case ID_GSM:
					++pos;
					bean.setGsm(rs.getString(pos));
					break;
				case ID_GSE:
					++pos;
					bean.setGse(rs.getString(pos));
					break;
				case ID_TISSUE:
					++pos;
					bean.setTissue(rs.getString(pos));
					break;
				case ID_ARRAY_ID:
					++pos;
					bean.setArrayId(rs.getString(pos));
					break;
				default:
					throw new DAOException("Unknown field id " + fieldList[i]);
				}
			}
		} catch (SQLException e) {
			throw new DataAccessException(e);
		}
		bean.isNew(false);
		bean.resetIsModified();

		return bean;
	}

	/**
	 * Transforms a ResultSet iterating on the expression_array on a ExpressionArrayBean bean using the names of the
	 * columns
	 *
	 * @param rs
	 *            the ResultSet to be transformed
	 * @return bean resulting ExpressionArrayBean bean
	 * @throws DAOException
	 */
	// 31
	public ExpressionArrayBean metaDataDecodeRow(ResultSet rs) throws DAOException {
		ExpressionArrayBean bean = this.createExpressionArrayBean();
		try {
			bean.setPlattform(rs.getString("plattform"));
			bean.setTitle(rs.getString("title"));
			bean.setGsm(rs.getString("gsm"));
			bean.setGse(rs.getString("gse"));
			bean.setTissue(rs.getString("tissue"));
			bean.setArrayId(rs.getString("array_id"));
		} catch (SQLException e) {
			throw new DataAccessException(e);
		}

		bean.isNew(false);
		bean.resetIsModified();

		return bean;
	}

	// ////////////////////////////////////
	// PREPARED STATEMENT LOADER
	// ////////////////////////////////////

	/**
	 * Loads all the elements using a prepared statement.
	 *
	 * @param ps
	 *            the PreparedStatement to be used
	 * @return an array of ExpressionArrayBean
	 * @throws DAOException
	 */
	// 32
	public ExpressionArrayBean[] loadByPreparedStatement(PreparedStatement ps) throws DAOException {
		return this.loadByPreparedStatement(ps, null);
	}

	/**
	 * Loads all the elements using a prepared statement specifying a list of fields to be retrieved.
	 *
	 * @param ps
	 *            the PreparedStatement to be used
	 * @param fieldList
	 *            table of the field's associated constants
	 * @return an array of ExpressionArrayBean
	 * @throws DAOException
	 */
	// 33
	public ExpressionArrayBean[] loadByPreparedStatement(PreparedStatement ps, int[] fieldList) throws DAOException {
		ResultSet rs = null;
		List<ExpressionArrayBean> v = null;
		try {
			rs = ps.executeQuery();
			v = new ArrayList<ExpressionArrayBean>();
			if (fieldList == null) {
				while (rs.next()) {
					v.add(decodeRow(rs));
				}
			} else {
				while (rs.next()) {
					v.add(decodeRow(rs, fieldList));
				}
			}

			return (ExpressionArrayBean[]) v.toArray(new ExpressionArrayBean[0]);
		} catch (SQLException e) {
			throw new DataAccessException(e);
		} finally {
			if (v != null) {
				v.clear();
				v = null;
			}
			getManager().close(rs);
		}
	}

	/**
	 * Loads all the elements using a prepared statement specifying a list of fields to be retrieved, and specifying the
	 * start row and the number of rows.
	 *
	 * @param ps
	 *            the PreparedStatement to be used
	 * @param startRow
	 *            the start row to be used (first row = 1, last row = -1)
	 * @param numRows
	 *            the number of rows to be retrieved (all rows = a negative number)
	 * @param fieldList
	 *            table of the field's associated constants
	 * @return an array of ExpressionArrayBean
	 * @throws DAOException
	 */
	// 34
	public ExpressionArrayBean[] loadByPreparedStatement(PreparedStatement ps, int[] fieldList, int startRow,
			int numRows) throws DAOException {
		ResultSet rs = null;
		try {
			rs = ps.executeQuery();
			return this.decodeResultSet(rs, fieldList, startRow, numRows);
		} catch (SQLException e) {
			throw new DataAccessException(e);
		} finally {
			this.getManager().close(rs);
		}
	}

	// _____________________________________________________________________
	//
	// LISTENER
	// _____________________________________________________________________
	private ExpressionArrayListener listener = null;

	/**
	 * Registers a unique ExpressionArrayListener listener.
	 */
	// 35
	public void registerListener(ExpressionArrayListener listener) {
		this.listener = listener;
	}

	/**
	 * Before the save of the ExpressionArrayBean bean.
	 *
	 * @param bean
	 *            the ExpressionArrayBean bean to be saved
	 */
	// 36
	private void beforeInsert(ExpressionArrayBean bean) throws DAOException {
		if (listener != null) {
			listener.beforeInsert(bean);
		}
	}

	/**
	 * After the save of the ExpressionArrayBean bean.
	 *
	 * @param bean
	 *            the ExpressionArrayBean bean to be saved
	 */
	// 37
	private void afterInsert(ExpressionArrayBean bean) throws DAOException {
		if (listener != null) {
			listener.afterInsert(bean);
		}
	}

	/**
	 * Before the update of the ExpressionArrayBean bean.
	 *
	 * @param bean
	 *            the ExpressionArrayBean bean to be updated
	 */
	// 38
	private void beforeUpdate(ExpressionArrayBean bean) throws DAOException {
		if (listener != null) {
			listener.beforeUpdate(bean);
		}
	}

	/**
	 * After the update of the ExpressionArrayBean bean.
	 *
	 * @param bean
	 *            the ExpressionArrayBean bean to be updated
	 */
	// 39
	private void afterUpdate(ExpressionArrayBean bean) throws DAOException {
		if (listener != null) {
			listener.afterUpdate(bean);
		}
	}

	/**
	 * Before the delete of the ExpressionArrayBean bean.
	 *
	 * @param bean
	 *            the ExpressionArrayBean bean to be deleted
	 */
	private void beforeDelete(ExpressionArrayBean bean) throws DAOException {
		if (listener != null) {
			listener.beforeDelete(bean);
		}
	}

	/**
	 * After the delete of the ExpressionArrayBean bean.
	 *
	 * @param bean
	 *            the ExpressionArrayBean bean to be deleted
	 */
	private void afterDelete(ExpressionArrayBean bean) throws DAOException {
		if (listener != null) {
			listener.afterDelete(bean);
		}
	}

	// _____________________________________________________________________
	//
	// UTILS
	// _____________________________________________________________________

	/**
	 * Retrieves the manager object used to get connections.
	 *
	 * @return the manager used
	 */
	// 40
	private Manager getManager() {
		return Manager.getInstance();
	}

	/**
	 * Frees the connection.
	 *
	 * @param c
	 *            the connection to release
	 */
	// 41
	private void freeConnection(Connection c) {
		this.getManager().releaseConnection(c); // back to pool
	}

	/**
	 * Gets the connection.
	 */
	// 42
	private Connection getConnection() throws DAOException {
		try {
			return this.getManager().getConnection();
		} catch (SQLException e) {
			throw new DataAccessException(e);
		}
	}
}
